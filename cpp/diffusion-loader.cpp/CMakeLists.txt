# 设置 CMake 最低版本要求
cmake_minimum_required(VERSION 3.22.1)
# 定义项目名称
project("sdloader")

# 指定项目输出动态链接库的目录,我这里是D:\Coding\Happy\MineGPT\cpp\libs
get_filename_component(CPP_ROOT_DIR "${CMAKE_CURRENT_SOURCE_DIR}/.." ABSOLUTE)
string(REPLACE "\\" "/" CPP_ROOT_DIR "${CPP_ROOT_DIR}") # 规范化路径
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CPP_ROOT_DIR}/libs") # .exe and .dll
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CPP_ROOT_DIR}/libs") # .so and .dylib
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CPP_ROOT_DIR}/libs") # .lib and .a


# 创建一个变量指向 stable-diffusion.cpp 目录
set(DIFFUSION_LOADER_DIR "${CMAKE_SOURCE_DIR}")
# 文件操作命令,用于从一个路径中提取特定部分,DIRECTORY: 路径中的目录部分,NAME: 文件名（带扩展名,NAME_WE: 文件名（不带扩展名,EXTENSION: 文件扩展名（带点
get_filename_component(STABLE_DIFFUSION_DIR ${DIFFUSION_LOADER_DIR}/../stable-diffusion.cpp ABSOLUTE)
# 打印stable-diffusion.cpp目录
message(WARNING "当前CMake的目录: ${DIFFUSION_LOADER_DIR}")
message(WARNING "stable-diffusion.cpp的目录: ${STABLE_DIFFUSION_DIR}")
# 创建stable-diffusion 编译配置变量,CACHE: 指存入CMake 缓存中,BOOL:缓存变量的类型,FORCE:强制将缓存中的这个变量设置为指定的值，无论它之前是什么值
set(SD_BUILD_EXAMPLES OFF CACHE BOOL "sd: build examples" FORCE)
set(SD_BUILD_SHARED_LIBS OFF CACHE BOOL "sd: build shared libs" FORCE)
set(SD_BUILD_SHARED_GGML_LIB OFF CACHE BOOL "sd: build ggml as a separate shared lib" FORCE)
set(SD_USE_SYSTEM_GGML OFF CACHE BOOL "sd: use system-installed GGML library" FORCE)
set(SD_VULKAN ON CACHE BOOL "sd: vulkan backend" FORCE)
set(SD_CUDA OFF CACHE BOOL "sd: cuda backend" FORCE)
set(SD_METAL OFF CACHE BOOL "sd: metal backend" FORCE)
set(SD_OPENCL OFF CACHE BOOL "sd: opencl backend" FORCE)
set(SD_SYCL OFF CACHE BOOL "sd: sycl backend" FORCE)
set(SD_MUSA OFF CACHE BOOL "sd: musa backend" FORCE)

# 为交叉编译环境下的主机编译任务创建一个临时的工具链文件,确保在交叉编译大环境下,部分代码能正确地为主机进行编译
if (CMAKE_MAKE_PROGRAM)
    # 这段代码动态地生成了一个 .cmake 文件 (ggml_vulkan_host_toolchain.cmake)。
    set(_GGML_VK_HOST_TC "${CMAKE_CURRENT_BINARY_DIR}/ggml_vulkan_host_toolchain.cmake")
    # 这个文件告诉 CMake，当编译那个特定的主机工具时，请不要使用 Android NDK 的交叉编译器，而是使用本机的编译器 (CMAKE_HOST_SYSTEM_NAME) 和构建系统 (Ninja)
    # 将 ninja.exe 的 Windows 路径转换为 CMake 兼容的路径（使用正斜杠）
    file(TO_CMAKE_PATH "${CMAKE_MAKE_PROGRAM}" _NINJA_EXECUTABLE_PATH)
    file(WRITE "${_GGML_VK_HOST_TC}" "# Autogenerated by llmedge CMake\n"
            "set(CMAKE_SYSTEM_NAME \"${CMAKE_HOST_SYSTEM_NAME}\")\n"
            "set(CMAKE_SYSTEM_PROCESSOR \"${CMAKE_HOST_SYSTEM_PROCESSOR}\")\n"
            "set(CMAKE_BUILD_TYPE Release)\n"
            "set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\n"
            "set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY NEVER)\n"
            "set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE NEVER)\n"
            "set(CMAKE_MAKE_PROGRAM \"${_NINJA_EXECUTABLE_PATH}\" CACHE FILEPATH \"\" FORCE)\n"
            "set(CMAKE_GENERATOR \"Ninja\" CACHE STRING \"\" FORCE)\n"
    )
    # 将刚刚生成的工具链文件路径设置到一个变量中。下游的 ggml 构建脚本会读取这个变量，并在需要时应用这个主机工具链
    set(GGML_VULKAN_SHADERS_GEN_TOOLCHAIN "${_GGML_VK_HOST_TC}" CACHE STRING "Toolchain for ggml-vulkan shader generator" FORCE)
endif()

# 告诉 ggml 的构建系统，需要启用 Vulkan 后端
set(GGML_VULKAN ON CACHE BOOL "ggml: vulkan" FORCE)

# 根据目标平台配置 Vulkan
if(ANDROID)
    # Android 平台：使用 NDK 的 Vulkan
    message(STATUS "配置 Android 平台的 Vulkan")
    
    # 在 Android NDK 的默认链接路径中查找 Vulkan 的动态库 (libvulkan.so)，并将其路径存入 VULKAN_LIB 变量。REQUIRED 表示如果找不到就报错
    find_library(VULKAN_LIB vulkan REQUIRED)
    
    # 根据主机操作系统（Host OS）动态确定 NDK 预编译工具链的路径
    if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
        set(HOST_PREBUILT_DIR "windows-x86_64")
    elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux")
        set(HOST_PREBUILT_DIR "linux-x86_64")
    elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Darwin")
        set(HOST_PREBUILT_DIR "darwin-x86_64")
    else()
        message(FATAL_ERROR "不支持的主机操作系统: ${CMAKE_HOST_SYSTEM_NAME}")
    endif()
    
    # 指定 Vulkan C 头文件 (vulkan/vulkan.h 等) 头文件的位置，现在路径是跨平台的
    set(Vulkan_INCLUDE_DIR "${ANDROID_NDK}/toolchains/llvm/prebuilt/${HOST_PREBUILT_DIR}/sysroot/usr/include")
    
    # 使用 FetchContent 下载 Vulkan C++ 头文件
    include(FetchContent)
    FetchContent_Declare(
            vulkan_hpp
            GIT_REPOSITORY https://github.com/KhronosGroup/Vulkan-Hpp.git
            GIT_TAG        v1.3.275  # Must match Android NDK's Vulkan version
            GIT_SHALLOW    TRUE
    )
    FetchContent_MakeAvailable(vulkan_hpp)
    
    # 给 stable-diffusion's ggml-vulkan 配置 Vulkan 环境
    set(Vulkan_INCLUDE_DIRS "${Vulkan_INCLUDE_DIR};${vulkan_hpp_SOURCE_DIR}")
    set(Vulkan_LIBRARIES "${VULKAN_LIB}")
    set(Vulkan_FOUND ON)
    set(Vulkan_INCLUDE_DIR "${Vulkan_INCLUDE_DIR}" CACHE PATH "Vulkan include directory" FORCE)
    set(Vulkan_LIBRARY "${VULKAN_LIB}" CACHE FILEPATH "Vulkan library" FORCE)
    
else()
    # 其他平台（Windows/Linux/macOS）：使用系统安装的 Vulkan SDK
    message(STATUS "配置桌面平台的 Vulkan (Windows/Linux/macOS)")
    
    # 使用标准的 find_package 查找 Vulkan SDK
    find_package(Vulkan REQUIRED)
    
    if(NOT Vulkan_FOUND)
        message(FATAL_ERROR "未找到 Vulkan SDK！请从 https://vulkan.lunarg.com/sdk/home 下载并安装 Vulkan SDK,并配置环境变量")
    endif()
    
    message(STATUS "找到 Vulkan SDK:")
    message(STATUS "  - 库: ${Vulkan_LIBRARIES}")
    message(STATUS "  - 头文件: ${Vulkan_INCLUDE_DIRS}")
    
    # 设置 Vulkan 变量供后续使用
    set(VULKAN_LIB ${Vulkan_LIBRARIES})
    
endif()

# 添加预编译的库
# A-add_subdirectory:将另一个目录下的 CMake 项目包含到当前的构建流程中。这个子目录必须有自己的 CMakeLists.txt 文件
add_subdirectory(${STABLE_DIFFUSION_DIR} ${CMAKE_CURRENT_BINARY_DIR}/stable-diffusion.cpp)
# 也许 ggml-vulkan 的构建脚本没有（或无法）自动包含 vulkan_hpp 的路径。这段代码检查 ggml-vulkan 这个目标是否存在，如果存在，就为其添加 vulkan_hpp 的头文件搜索路径
if (TARGET ggml-vulkan AND ANDROID)
    target_include_directories(ggml-vulkan PRIVATE ${vulkan_hpp_SOURCE_DIR})
endif()
# B-定义JNI库 sdloader 库, 指定是STATIC (静态库, .a) 还是 SHARED (共享库, .so)。模块化的内部库通常设为 STATIC，最终给 JNI 调用的设为 SHARED
add_library(sdloader SHARED diffusion_loader_jni.cpp)
# C-指定头文件 (.h, .hpp) 的搜索路径。为JNI库添加 stable-diffusion 的头文件搜索路径
# PUBLIC: 我自己需要这个路径，链接我的目标也需要这个路径。 (最常用)
# PRIVATE: 只有我自己（库内部）需要这个路径，链接我的目标不需要。
# INTERFACE: 我自己不需要，但链接我的目标需要。（用于纯头文件库）
target_include_directories(sdloader
        PUBLIC
        ${STABLE_DIFFUSION_DIR}
        ${STABLE_DIFFUSION_DIR}/thirdparty
)

# 编译优化
# A-指定所需的 C 和 C++ 标准，确保代码能以正确的语言版本进行编译
target_compile_features(sdloader PUBLIC c_std_11 cxx_std_17)
# B-添加编译器标志。
if(ANDROID)
    #  -fvisibility=hidden: 非常重要的优化。它将库中所有符号的可见性默认设为隐藏，只有显式导出的（如 JNI 函数）才可见。这能减小库体积，提高加载速度。
    #  -ffunction-sections -fdata-sections: 将每个函数和数据放到独立的节中
    target_compile_options(sdloader PUBLIC -fvisibility=hidden -fvisibility-inlines-hidden -ffunction-sections -fdata-sections)
    # 类似gradle的implementation,给sdloader库添加依赖 android,log(标准的Android NDK库),stable-diffusion
    target_link_libraries(sdloader
            android log
            stable-diffusion
    )
    if(SD_VULKAN)
        target_link_libraries(sdloader vulkan)
    endif()
endif ()


# C-添加链接器标志。
#  -Wl,--gc-sections: 配合 -ffunction-sections，告诉链接器移除所有未被使用的代码和数据节（死代码消除），显著减小库体积。
#  -flto: 启用链接时优化 (Link-Time Optimization)。这是一种强大的全局优化技术，链接器可以在所有代码都可见的情况下进行内联、常量传播等优化，能提升性能并减小体积。
#  -Wl,--exclude-libs,ALL: 另一个体积优化选项，防止静态库中的所有符号都被添加到动态符号表中
target_link_options(sdloader PRIVATE -Wl,--gc-sections -flto -Wl,--exclude-libs,ALL)
